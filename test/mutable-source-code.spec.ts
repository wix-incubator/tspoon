/// <reference path="../typings/tsd.d.ts" />

import { expect } from 'chai';
import * as chai from "chai";
import * as ts from "typescript";
import { MutableSourceCode, Replacement} from "../src/mutable-source-code";
import { traverseAst } from '../src/traverse-ast';
import { findCodeRange, findCodePosition } from "../test-kit/index";
import { FileTranspilationHost } from '../src/hosts';
import { defaultCompilerOptions } from '../src/configuration';
import { RawSourceMap, SourceMapConsumer, SourceMapGenerator } from 'source-map';

function makeReplacement(source: string, atStr: string, insStr: string): Replacement {
	const textRange = findCodeRange(source, atStr);
	return { start: textRange.pos, end: textRange.end, str: insStr };
}

function makeLineInsersion(source: string, atStr: string, insStr: string): Replacement {
	const textRange = findCodeRange(source, atStr);
	return { start: textRange.pos, end: textRange.pos, str: insStr + "\n" };
}

function aSourceMapperFor(source: string): MutableSourceCode {
	const ast = ts.createSourceFile("test.ts", source, defaultCompilerOptions.target, true);
	return new MutableSourceCode(ast);
}

function matchPositions(source: string, target: string, sourceMap: RawSourceMap, text: string) {
	const positionBeforeChange: SourceMap.Position = findCodePosition(source, text);
	const positionAfterChange: SourceMap.Position = findCodePosition(target, text);
	const mapConsumer = new SourceMapConsumer(sourceMap);
	const mappedPosition: SourceMap.Position = mapConsumer.originalPositionFor(positionAfterChange);
	expect({ line: mappedPosition.line, column: mappedPosition.column })
		.to.eql({ line: positionBeforeChange.line, column: positionBeforeChange.column });
}

function transpile(source: string): { code: string, map: RawSourceMap } {
	const ast = ts.createSourceFile("test.ts", source, defaultCompilerOptions.target, true);
	const compilerHost = new FileTranspilationHost(ast);
	const program = ts.createProgram(["test.ts"], defaultCompilerOptions, compilerHost);
	program.emit();
	return {
		code: compilerHost.output,
		map: compilerHost.sourceMap
	};
}

describe("given a source code", ()=> {

	const source = `class A {}
PLACE_HOLDERclass B {}
fubar();`;
	var mutableCode;
	before(() =>{
		mutableCode = aSourceMapperFor(source);
	});
	describe("and given a replacement command, sourcemapper should", ()=> {

		const target = `class A {}
@bar
@foo
class B {}
fubar();`;
		before(() =>{
			const action1 = makeLineInsersion(source, "PLACE_HOLDER", "@bar");
			const action2 = makeReplacement(source, "PLACE_HOLDER", "@foo\n");
			// TODO uncomment
			const action3 = makeLineInsersion(source, "PLACE_HOLDER", "@baz");
			mutableCode.execute([action1, action2/*, action3*/]);
		});

		it("generate a new string that matches the expected target", ()=> {

			expect(mutableCode.code).to.equal(target);
		});

		it("generate correct sourcemap that reflects the changes", ()=> {

			matchPositions(source, mutableCode.code, mutableCode.sourceMap, "class B");
		});

		it("map the changes onto a sourcemap generated by typescript", ()=> {

			var result = transpile(mutableCode.code);

			const sourceMap = mutableCode.translateMap(result.map);

			matchPositions(source, result.code, sourceMap, "fubar()");
		});
	});
});


