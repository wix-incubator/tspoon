/// <reference path="../typings/tsd.d.ts" />

import { expect } from 'chai';
import * as chai from "chai";
import * as ts from "typescript";
import { MutableSourceCode, Insertion } from "../src/mutable-source-code";
import { traverseAst } from '../src/traverse-ast';
import { findCodeRange, findCodePosition } from "../test-kit/index";
import { FileTranspilationHost } from '../src/file-transpilation-host';
import { defaultCompilerOptions } from '../src/configuration';
import { RawSourceMap, SourceMapConsumer, SourceMapGenerator } from 'source-map';

function anInsertion(source: string, atStr: string, insStr: string): Insertion {
    return (
        { position: findCodeRange(source, atStr).pos, str: insStr }
    );
}

function aSourceMapperFor(source: string): MutableSourceCode {
    const ast = ts.createSourceFile("test.ts", source, defaultCompilerOptions.target, true);
    return new MutableSourceCode(ast);
}

function matchPositions(source: string, target: string, sourceMap: RawSourceMap, text: string) {
    const positionBeforeChange: SourceMap.Position = findCodePosition(source, text);
    const positionAfterChange: SourceMap.Position = findCodePosition(target, text);
    const mapConsumer = new SourceMapConsumer(sourceMap);
    const mappedPosition: SourceMap.Position = mapConsumer.originalPositionFor(positionAfterChange);
    expect({ line: mappedPosition.line, column: mappedPosition.column })
        .to.eql({ line: positionBeforeChange.line, column: positionBeforeChange.column });
}

function transpile(source: string): { code: string, map: RawSourceMap } {
    const ast = ts.createSourceFile("test.ts", source, defaultCompilerOptions.target, true);
    const compilerHost = new FileTranspilationHost(ast);
    const program = ts.createProgram(["test.ts"], defaultCompilerOptions, compilerHost);
    program.emit();
    return {
        code: compilerHost.output,
        map: compilerHost.sourceMap
    };
}

describe("given a source code and a str to prepend, sourcemapper should", ()=> {

    const source = "class A {}\nclass B {}\nfubar();";

    const target = "class A {}\n@foo\nclass B {}\nfubar();";

    const insertion: Insertion = anInsertion(source, "class B", "@foo\n");
    var mutableCode: MutableSourceCode = aSourceMapperFor(source);
    mutableCode.execute([insertion]);

    it("generate a new string that matches the expected target", ()=> {

        expect(mutableCode.code).to.equal(target);
    });

    it("generate correct sourcemap that reflects the changes", ()=> {

        matchPositions(source, mutableCode.code, mutableCode.sourceMap, "class B");
    });

    it("map the changes onto a sourcemap generated by typescript", ()=> {

        var result = transpile(mutableCode.code);

        const sourceMap = mutableCode.translateMap(result.map);

        matchPositions(source, result.code, sourceMap, "fubar()");
    });
});
